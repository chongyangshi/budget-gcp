// This file stores ingress specifications for Traefik to forward to

module "service_nginx_example" {
  source = "./service_proxy"

  // First domain will be used as the main TLS name and common name by
  // the Let's Encrypt ACME client, all will be present as SANs on the
  // certificate.
  service_hostnames = ["example.com", "www.example.com"]

  // Backend service name and port for traffic to be forwarded to
  service_name      = "nginx-example"
  service_port      = 80

  // Backend service namespace for the above, if in a namespace different
  // from the ingress namespace, an nginx service proxy will be created
  // automatically in the ingress namespace to forward ingress traffic 
  // from Traefik across namespaces.
  service_namespace = "ingress"

  // If the backend service runs in a namespace different from the ingress
  // namespace, the service proxy port exposed to Traefik (and via it the
  // internet) can be made different to the actual backend service port
  // and its Pods' container ports. This allows GCP firewall policies to
  // shield backend ports over VPC-native networking in the event the  
  // ingress instance is compromised. If set, this port must be allowed in
  // external_ingress_tcp_ports and/or external_ingress_udp_ports.
  // If the service_namespace is the same as the ingress namespace, then 
  // this option takes no effect.
  ingress_port      = 80
  
  // Other configurations, such as customly-configured middlewares, not 
  // terminating TLS with Traefik, and using a vendored service proxy nginx 
  // image, can be configured in service_proxy/variables.tf

  // traefik_terminate_tls       = false
  // service_traefik_middlewares = ["testBasicAuth@file", "testProxyProtocolHeader@file"]
}

// Example deployment in the ingress namespace receiving forwarded
// traffic from Traefik. You may wish to use Helm instead of the
// Kubernetes provider, or a GitOps system like ArgoCD for deploying
// actual applications instead.
resource "kubernetes_deployment" "nginx_example" {
  metadata {
    name      = "nginx-example"
    namespace = "ingress"

    labels = {
      app = "nginx-example"
    }
  }

  spec {
    replicas = 2

    selector {
      match_labels = {
        app = "nginx-example"
      }
    }

    template {
      metadata {
        labels = {
          app = "nginx-example"
        }
      }

      spec {
        container {
          image = "nginx:stable"
          name  = "nginx-example"

          resources {
            limits = {
              cpu    = "200m"
              memory = "256Mi"
            }
            requests = {
              cpu    = "100m"
              memory = "128Mi"
            }
          }

        }
      }
    }
  }
}

resource "kubernetes_service" "nginx_example" {
  metadata {
    name      = "nginx-example"
    namespace = "ingress"
  }

  spec {
    selector = {
      app = kubernetes_deployment.nginx_example.spec.template.metadata.0.labels.app
    }

    port {
      port        = 80
      target_port = 80
      protocol    = "TCP"
    }

    type = "ClusterIP"
  }
}
